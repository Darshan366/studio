/**
 * @fileOverview Firestore Security Rules for a mutual matching application.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure data access based on user authentication and explicit authorization.
 * Clients are generally prevented from writing directly to collections that manage matches or conversations;
 * these are handled by backend functions to maintain data integrity. The rules leverage denormalization of user
 * data (specifically, storing user lists directly in conversation documents) to achieve authorization independence
 * and improve performance.
 *
 * Data Structure:
 * - /swipes/{swipeId}: Stores individual swipe actions performed by users.
 * - /matches/{matchId}: Stores match information between two users.  Match creation and updates are handled by a backend.
 * - /conversations/{matchId}: Stores conversation metadata, including a denormalized list of participating user IDs.
 * - /conversations/{matchId}/messages/{messageId}: Stores individual messages within a conversation.
 *
 * Key Security Decisions:
 * - Clients can create swipes.
 * - Clients cannot directly create, update, or delete matches or conversations; these are managed by backend functions.
 * - Authorization for conversations and messages is based on a denormalized `users` array within the conversation document.
 * - Listing of messages is only allowed within the context of a specific conversation.
 *
 * Denormalization for Authorization:
 * The `conversations` document includes a `users` array containing the UIDs of the participants. This denormalization
 * allows security rules for messages to efficiently verify user access without requiring additional `get()` operations
 * to fetch user membership information.
 *
 * Structural Segregation:
 * The application uses distinct collections for swipes, matches, conversations, and messages.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to swipe documents.  Authenticated users can create swipe documents.
     * @path /swipes/{swipeId}
     * @allow (create) - An authenticated user can create a swipe document.
     *   Example: request.auth.uid = 'user123'; request.resource.data.swiperId = 'user123'
     * @deny (create) - An unauthenticated user attempts to create a swipe document.
     *   Example: request.auth == null
     * @principle Allows authenticated users to create swipe data.
     */
    match /swipes/{swipeId} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to match documents. Matches are managed by a Cloud Function, not clients.
     * @path /matches/{matchId}
     * @allow (get) - No direct client access allowed.
     * @deny (create) - Any client attempting to create a match document.
     *   Example: request.auth.uid = 'user123'
     * @principle Restricts client-side creation of matches to ensure data integrity.
     */
    match /matches/{matchId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to conversation documents.  Conversations are managed by a Cloud Function, not clients.
     * @path /conversations/{matchId}
     * @allow (get) - No direct client access allowed.
     * @deny (create) - Any client attempting to create a conversation document.
     *   Example: request.auth.uid = 'user123'
     * @principle Restricts client-side creation of conversations to ensure data integrity.
     */
    match /conversations/{matchId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to message documents within a conversation. Only users in the conversation can read/write.
     * @path /conversations/{matchId}/messages/{messageId}
     * @allow (create) - A user in the conversation creates a new message.
     *   Example: request.auth.uid = 'user123', conversation.data.users = ['user123', 'user456']
     * @deny (create) - A user not in the conversation attempts to create a message.
     *   Example: request.auth.uid = 'user789', conversation.data.users = ['user123', 'user456']
     * @allow (list) - A user in the conversation lists messages.
     * @deny (list) - A user not in the conversation attempts to list messages.
     * @principle Enforces conversation-based access control for messages.
     */
    match /conversations/{matchId}/messages/{messageId} {
      allow get: if false;
      allow list: if conversationContainsUser(matchId, request.auth.uid);
      allow create: if conversationContainsUser(matchId, request.auth.uid);
      allow update: if false;
      allow delete: if false;
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the conversation document at the given path contains the specified user ID in its 'users' array.
     * @param {string} matchId The ID of the match, corresponding to the conversation document.
     * @param {string} userId The ID of the user to check for.
     * @return {boolean} True if the user is in the conversation, false otherwise.
     */
    function conversationContainsUser(matchId, userId) {
      return get(/databases/$(database)/documents/conversations/$(matchId)).data.users.hasAny([userId]);
    }
  }
}