/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a user-centric security model for a fitness application.
 *
 * Data Structure:
 * - User profiles are stored in `/users/{userId}`.
 * - Swipes are stored in `/swipes/{swipeId}`.
 * - Matches are stored in `/matches/{matchId}`.
 * - Conversations are stored in `/conversations/{matchId}`.
 * - Messages within conversations are stored in `/conversations/{matchId}/messages/{messageId}`.
 *
 * Key Security Decisions:
 * - Users can only read/write their own profile data.
 * - Clients can only write swipe data, not read it.
 * - Matches are created server-side and are read-only for clients.
 * - Conversations are accessible to the two users involved.
 * - Messages within conversations are accessible to the two users involved.
 *
 * Denormalization for Authorization:
 * - The `Conversation` and `Message` security rules rely on the `users` array within the `Conversation` document to authorize access. This avoids needing to query a separate collection to determine participants.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile information.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *   request.auth.uid == 'user123' and request.resource.data.uid == 'user123'
     * @allow (get) User with ID 'user123' can read their profile.
     *   request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' can update their profile.
     *   request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' cannot create a profile with a different ID.
     *   request.auth.uid == 'user123' but request.resource.data.uid == 'user456'
     * @deny (update) User with ID 'user123' cannot update someone else's profile.
     *   request.auth.uid == 'user456'
     * @deny (delete) No one can delete a user profile (handled via account deletion).
     *   request.auth.uid == 'user123'
     * @principle Enforces document ownership for reads and writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.uid == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if false;
    }

    /**
     * @description Controls access to swipe data. Swipes are write-only for clients.
     * @path /swipes/{swipeId}
     * @allow (create) Any authenticated user can create a swipe.
     *   request.auth.uid != null
     * @deny (get) No one can read swipe data directly.
     *   request.auth.uid == 'user123'
     * @deny (list) No one can list swipe data.
     *   request.auth.uid == 'user123'
     * @deny (update) No one can update swipe data.
     *   request.auth.uid == 'user123'
     * @deny (delete) No one can delete swipe data.
     *   request.auth.uid == 'user123'
     * @principle Restricts client access to write-only. Data managed server-side.
     */
    match /swipes/{swipeId} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to match data. Matches are read-only for clients.
     * @path /matches/{matchId}
     * @allow (get) Any authenticated user can read a match if they are one of the users in the match.
     *   request.auth.uid == 'user123' and 'user123' in resource.data.users
     * @allow (list) Any authenticated user can list matches.
     *   request.auth.uid == 'user123'
     * @deny (create) No one can create match data directly (server-side only).
     *   request.auth.uid == 'user123'
     * @deny (update) No one can update match data directly (server-side only).
     *   request.auth.uid == 'user123'
     * @deny (delete) No one can delete match data directly (server-side only).
     *   request.auth.uid == 'user123'
     * @principle Restricts client access to read-only. Data managed server-side.
     */
    match /matches/{matchId} {
      allow get: if isSignedIn() && resource.data.users.hasAny([request.auth.uid]);
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to conversation metadata.
     * @path /conversations/{matchId}
     * @allow (get) Any participant can read a conversation.
     *   request.auth.uid == 'user123' and 'user123' in resource.data.users
     * @allow (list) No one can list conversations.
     *   request.auth.uid == 'user123'
     * @allow (create) Any participant can create a conversation.
     *   request.auth.uid == 'user123' and 'user123' in request.resource.data.users
     * @allow (update) Any participant can update a conversation.
     *   request.auth.uid == 'user123' and 'user123' in request.resource.data.users
     * @deny (create) A user cannot create a conversation with users that do not include themselves.
     *   request.auth.uid == 'user123' and 'user123' not in request.resource.data.users
     * @deny (update) A user cannot update a conversation for the wrong users.
     *   request.auth.uid == 'user123' and 'user123' not in request.resource.data.users
     * @deny (delete) No one can delete a conversation.
     *   request.auth.uid == 'user123'
     * @principle Enforces shared access based on participants.
     */
    match /conversations/{matchId} {
      allow get: if isSignedIn() && resource.data.users.hasAny([request.auth.uid]);
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.users.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && resource.data.users.hasAny([request.auth.uid]);
      allow delete: if false;
    }

    /**
     * @description Controls access to messages within a conversation.
     * @path /conversations/{matchId}/messages/{messageId}
     * @allow (get) Any participant of the conversation can read a message.
     *   request.auth.uid == 'user123' and get(/databases/$(database)/documents/conversations/$(matchId)).data.users.hasAny(['user123'])
     * @allow (list) Any participant of the conversation can list messages.
     *   request.auth.uid == 'user123' and get(/databases/$(database)/documents/conversations/$(matchId)).data.users.hasAny(['user123'])
     * @allow (create) Any participant of the conversation can create a message.
     *   request.auth.uid == 'user123' and get(/databases/$(database)/documents/conversations/$(matchId)).data.users.hasAny(['user123'])
     * @deny (update) No one can update a message.
     *   request.auth.uid == 'user123'
     * @deny (delete) No one can delete a message.
     *   request.auth.uid == 'user123'
     * @principle Enforces shared access based on conversation participants, using get() for subcollection access.
     */
    match /conversations/{matchId}/messages/{messageId} {
      allow get: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(matchId)).data.users.hasAny([request.auth.uid]);
      allow list: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(matchId)).data.users.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(matchId)).data.users.hasAny([request.auth.uid]);
      allow update: if false;
      allow delete: if false;
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}